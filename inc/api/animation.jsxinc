/**
 * Animation IO
 * @namespace
 * @category DuIO
 */
DuIO.Animation = {};


/**
 * Pastes the animation previously copied by {@link Duik.Animation.copy} to the selected properties.
 * @param {DuAELayerAnimation[]} data The animation data to paste
 * @param {CompItem} [comp] The composition.
 * @param {Boolean} [replace=false] - Whether to completely erase and replace the current animation
 * @param {Boolean} [offset=false] - Whether to offset the animation from the current value
 * @param {Boolean} [reverse=false] - Whether to reverse the animation
 * @param {string[]} [matchNames=[]] A filter to apply only on specific property types
 * @param {Boolean} [keyframesOnly=true] - If false, the value of properties without keyframes will be set too.
 * @param {Boolean} [expressions=false] - If true, the expression is set too.
 */
DuIO.Animation.paste = function ( layers, data, replace, offset, reverse, matchNames, keyframesOnly, expressions )
{
	var comp = DuAEProject.getActiveComp();
	if (!comp) return;

    if (typeof layers === 'undefined')
	{
		layers = DuAEComp.getSelectedLayers();
		if (layers.length == 0) layers = comp.layers;
	}
	if (layers.length == 0) return;

    //options
    var time = comp.time;
	if (data.firstKeyFrameTime) time -= data.firstKeyFrameTime;
    replace = def( replace, false );
    offset = def( offset, false );
    reverse = def( reverse, false );
	matchNames = def(matchNames, []);
	keyframesOnly = def( keyframesOnly, true);
	expressions = def( expressions, !keyframesOnly);

    DuAE.beginUndoGroup(DuScriptUI.String.PASTE_KEYFRAMES, false);
    DuAEProject.setProgressMode(true);

    var remaining = DuAELayer.setAnims(layers, data, time, undefined, expressions, keyframesOnly, replace, matchNames, offset, reverse);

    if (remaining.length > 0)
    {
        var ui_pasteLayerPicker = DuScriptUI.layerPickerDialog("Missing layers");

        for (var i = 0, num = remaining.length; i < num; i++)
        {
            ui_pasteLayerPicker.addSelector(remaining[i]._index + ' | ' + remaining[i]._name);
            //try to preselect by name
            var ok = false;
            for (var j = 1, numLayers = comp.numLayers; j <= numLayers; j++)
            {
                var l = comp.layer(j);
                if (l.name == remaining[i]._name)
                {
                    ui_pasteLayerPicker.layerPicker.selectors[i].setCurrentIndex(j);
                    ok = true;
                    break;
                }
            }
            if (!ok && remaining[i]._index > 0 && remaining[i]._index <= comp.numLayers) ui_pasteLayerPicker.layerPicker.selectors[i].setCurrentIndex(remaining[i]._index);
        }

        ui_pasteLayerPicker.onAccept = function () {
            DuAE.beginUndoGroup(DuScriptUI.String.PASTE_KEYFRAMES, false);
            DuAEProject.setProgressMode(true);
            DuAELayer.setAllAnims(
                ui_pasteLayerPicker.getLayers(),
                remaining,
                time,
                undefined,
                expressions,
                keyframesOnly,
                replace,
                matchNames,
                offset,
                reverse
            );
            DuAEProject.setProgressMode(false);
            DuAE.endUndoGroup(DuScriptUI.String.PASTE_KEYFRAMES);
        };

        DuAEProject.setProgressMode(false);
        DuScriptUI.showUI(ui_pasteLayerPicker);
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup(DuScriptUI.String.PASTE_KEYFRAMES);

}

/**
 * Copies all the animations on selected layers, and saves them to a Json file.
 * @param {File} file The file to save the data
 * @param {Layer[]|DuList<Layer>|LayerCollection} [layers] An array of Layers or LayerCollection with the animation. Selected layers from the current comp if omitted.
 * @param {Boolean} [selectedKeysOnly] Wether to copy only selected keys or not. If omitted, will be true if there are selected keyframes, false otherwise.
 * @param {float[]}	[timeRange] The time range, an array of two time values, in seconds. If omitted, will use the keyframes if some are selected, or the work area of the comp.
 * @return {DuAELayerAnimation[]} The animations
 */
DuIO.Animation.toJson = function( file, layers, selectedKeysOnly, timeRange )
{
    layers = def( layers, DuAEComp.getSelectedLayers() );
    if (layers.length == 0) return;
    var comp = layers[0].containingComp;

    //wether to store only selected keys if there are any
    selectedKeysOnly = def( selectedKeysOnly, DuAELayer.haveSelectedKeys(layers) );
    
    //end time of the animation to store
    var endTime = comp.workAreaDuration + comp.workAreaStart;
    //start time of the animation to store
    var startTime;
    // If there are selected keys, look for the time of the first one
    if (selectedKeysOnly) startTime = DuAELayer.firstKeyFrameTime(layers,true);
    else startTime = comp.workAreaStart;

    var data = {};
	data.duio = {};
	data.duio.version = DuESF.scriptVersion.fullVersion;
	data.duio.animation = true;
	data.duio.rig = false;

	//copy the animation
	var anims  = DuAELayer.getAnims( layers, selectedKeysOnly, [startTime, endTime] );
	//clean data
	data.layers = DuIO.Animation.cleanExportData(anims);

	//save data
	DuFile.saveJSON(data,file);

    return anims;
}

/**
 * Loads an animation file and applies it on the layers
 * @param {File} jsonFile The file containing the animation
 * @param {Layer[]|DuList<Layer>|LayerCollection} [layers] The layers. If omitted, will get the selected layers from the current comp, or all layers if none are selected.
 * @param {Boolean} [keyframesOnly=false] If true, will load only keyframes, but not static values or expressions.
 * @param {string[]} [matchNames=[]] A filter for the properties to load. If empty, will load all properties.
 * @param {Boolean} [offset=false] Whether to offset the current values or use absolute values.
 * @param {Boolean} [reverse=false] Whether to reverse the keyframes in time.
 */
DuIO.Animation.fromJson = function( jsonFile, layers, keyframesOnly, matchNames, offset, reverse )
{
	if (!jsonFile.exists) return;
	
	keyframesOnly = def( keyframesOnly, false );

	DuAE.beginUndoGroup( DuScriptUI.String.IMPORT_ANIMATION, false );
	DuAEProject.setProgressMode(true);

	var data = DuFile.parseJSON( jsonFile );
	//TODO version check
	var anim = data.layers;
	//clean data
	anim  = DuIO.Animation.cleanImportData(anim);

	DuIO.Animation.paste( layers, anim, false, offset, reverse, matchNames, keyframesOnly );

	DuAEProject.setProgressMode(false);
	DuAE.endUndoGroup( DuScriptUI.String.IMPORT_ANIMATION );
}

/**
 * Cleans data from an After Effects animation before exporting it.<br />
 * This is a low-level function which you may need only if building your own export formats.<br />
 * It cleans the data returned by the "getAnim" functions  (see {@link DuAELayer.getAnim}, {@link DuAELayer.getAnims}, {@link DuAEProperty.getAnim}) to be able to store it in a text file.
 * @param {object}	data	The animation
 * @return {object}	The data cleaned
 */
DuIO.Animation.cleanExportData = function (data)
{
	var newData = data;
	if (newData.keys)
	{
		for (var k = 0, num =  newData.keys.length ; k < num; k++)
		{
			newData.keys[k]._inInterpolationType = DuIO.Animation.keyframeInterpolationTypeToName(newData.keys[k]._inInterpolationType);
			newData.keys[k]._outInterpolationType = DuIO.Animation.keyframeInterpolationTypeToName(newData.keys[k]._outInterpolationType);
		}
	}
	if (newData.anims)
	{
		for (var a = 0, num =  newData.anims.length ; a < num; a++)
		{
			newData.anims[a] = DuIO.Animation.cleanExportData(newData.anims[a]);
		}
	}
	if (newData instanceof Array)
	{
		for (var a = 0, num =  newData.length ; a < num; a++)
		{
			newData[a] = DuIO.Animation.cleanExportData(newData[a]);
		}
	}

	return newData;
}

/**
 * Cleans data from a JSON before loading it.<br />
 * This is a low-level function which you may need only if building your own import formats.<br />
 * It cleans the data stored after having used {@link DuAEF.Interchange.animation.cleanAnimExportData}<br />
 * to be able to set the animations using the "setAnim" functions (see {@link DuAEF.DuAE.Layer.setAnim}, {@link DuAEF.DuAE.Property.setAnim}).
 * @param {object}	data	The animation
 * @return {object}	The data cleaned
 */
DuIO.Animation.cleanImportData = function (data)
{
	var newData = data;
	if (newData.keys)
	{
		for (var k = 0, num =  newData.keys.length ; k < num; k++)
		{
			newData.keys[k] = DuIO.Animation.cleanKeyframeImportData(newData.keys[k]);
		}
	}
	if (newData.anims)
	{
		for (var a = 0, num =  newData.anims.length ; a < num; a++)
		{
			newData.anims[a] = DuIO.Animation.cleanImportData(newData.anims[a]);
		}
	}
	if (newData instanceof Array)
	{
		for (var a = 0, num =  newData.length ; a < num; a++)
		{
			newData[a] = DuIO.Animation.cleanImportData(newData[a]);
		}
	}

	return newData;
}

/**
 * Cleans data from a JSON before loading it.<br />
 * This is a low-level function which you may need only if building your own import formats.<br />
 * It cleans the data stored after having used {@link DuAEF.Interchange.animation.cleanAnimExportData}<br />
 * to be able to set the animations using the "setAnim" functions (see {@link DuAEF.DuAE.Layer.setAnim}, {@link DuAEF.DuAE.Property.setAnim}).
 * @memberof DuAEF.Interchange.animation
 * @param {object}	keyframeData	The keyframe data which is being loaded
 * @return {object}	The data cleaned
 */
DuIO.Animation.cleanKeyframeImportData = function (keyframeData)
{
	var newData = keyframeData;
	newData._inInterpolationType = DuIO.Animation.keyframeInterpolationNameToType(newData._inInterpolationType);
	newData._outInterpolationType = DuIO.Animation.keyframeInterpolationNameToType(newData._outInterpolationType);
	for (var i = 0, num = newData.inEase.length; i < num; i++)
	{
		var inInfluence = newData.inEase[i].influence;
		if (inInfluence < 0.1) inInfluence = 0.1;
		if (inInfluence > 100) inInfluence = 100;
		var outInfluence = newData.outEase[i].influence;
		if (outInfluence < 0.1) outInfluence = 0.1;
		if (outInfluence > 100) outInfluence = 100;
		newData.inEase[i] = new KeyframeEase(newData.inEase[i].speed, inInfluence);
		newData.outEase[i] = new KeyframeEase(newData.outEase[i].speed, outInfluence);
	}

	// If the value is a path
	if (typeof newData.value.vertices !== 'undefined')
	{
		var s = new Shape();
		var v = newData.value;
		s.closed = v.closed;
		s.featherInterps = v.featherInterps;
		s.featherRadii = v.featherRadii;
		s.featherRelCornerAngles = v.featherRelCornerAngles;
		s.featherRelSegLocs = v.featherRelSegLocs;
		s.featherSegLocs = v.featherSegLocs;
		s.featherTensions = v.featherTensions;
		s.featherTypes = v.featherTypes;
		s.inTangents = v.inTangents;
		s.outTangents = v.outTangents;
		s.vertices = v.vertices;
		newData.value = s;
	}

	return newData;
}

/**
 * Gets the name of an After Effects interpolation type.<br />
 * This is a low-level function which you should not need.<br />
 * It used by {@link DuIO.Animation.cleanAnimExportData} to store interpolation with their names.
 * @param {KeyframeInterpolationType}	type	The After Effects interpolation type
 * @return {string}	The interpolation name or empty string if not found
 */
DuIO.Animation.keyframeInterpolationTypeToName = function (type)
{
	if (type == KeyframeInterpolationType.LINEAR) return 'linear';
	if (type == KeyframeInterpolationType.BEZIER) return 'bezier';
	if (type == KeyframeInterpolationType.HOLD) return 'hold';
	else return '';
}

/**
 * Gets the After Effects interpolation type with its name.<br />
 * This is a low-level function which you should not need.<br />
 * It used by {@link DuAEF.Interchange.cleanAnimImportData} to set interpolation from their names.
 * @memberof DuAEF.Interchange.animation
 * @param {string}	name	The interpolation name
 * @return {KeyframeInterpolationType}	The interpolation type or null if not found
 */
DuIO.Animation.keyframeInterpolationNameToType = function (name)
{
	if (!name) return KeyframeInterpolationType.LINEAR;
	name = name.toString();
	if (name.toLowerCase() == 'linear' || name == '6612') return KeyframeInterpolationType.LINEAR;
	else if (name.toLowerCase() == 'bezier' || name == '6613') return KeyframeInterpolationType.BEZIER;
	else if (name.toLowerCase() == 'hold' || name == '6614') return KeyframeInterpolationType.HOLD;
	else return null;
}
